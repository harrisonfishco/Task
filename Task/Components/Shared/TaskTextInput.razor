@typeparam T
@inherits InputBase<T>

<div>
    <label for="@instance">@Label</label>
    <input id="@instance" type="@GetInputType()" @bind="@CurrentValue" disabled="@Disabled"/>
</div>

@code {
    [Parameter]
    public string Label { get; set; } = string.Empty;

    [Parameter]
    public bool Disabled { get; set; } = false;

    [Parameter]
    public InputType Type { get; set; } = InputType.Default;

    private Guid instance = Guid.NewGuid();

    private string GetInputType()
    {
        string res = string.Empty;
        switch(Type)
        {
            default:
            case InputType.Default:
                res = "text";
                break;
            case InputType.Password:
                res = "password";
                break;
            case InputType.Numeric:
                res = "number";
                break;
        }
        return res;
    }

    /*
    protected override bool TryParseValueFromString(string? value, out string result, out string validationErrorMessage)
        {
        result = value ?? string.Empty;
        validationErrorMessage = string.Empty;
        return true;
    }
    */

    protected override bool TryParseValueFromString(string value, out T result, out string validationErrorMessage)
    {
        bool res = false;
        result = default;
        validationErrorMessage = null;
        try
        {
            if (result is string)
            {
                result = (T)(object)value;
                res = true;
            }
            else if (result is int)
            {
                if (int.TryParse(value, out var intValue))
                {
                    result = (T)(object)intValue;
                    res = true;
                }
            }
            else if (result is double)
            {
                if (double.TryParse(value, out var doubleValue))
                {
                    result = (T)(object)doubleValue;
                    res = true;
                }
            }
            else if (result is short)
            {
                if (short.TryParse(value, out var shortValue))
                {
                    result = (T)(object)shortValue;
                    res = true;
                }
            }
            else 
            {
                throw new NotSupportedException($"Type {typeof(T).Name} is not supported");
            }
            //float
            //short

            result = default;
        }
        catch (Exception)
        {
            result = default;
            validationErrorMessage = "The input is not valid.";
        }
        return res;
    }

    public enum InputType
    {
        Default,
        Password,
        Numeric,
    }
}
