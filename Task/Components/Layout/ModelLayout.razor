@using Microsoft.EntityFrameworkCore;
@using Microsoft.EntityFrameworkCore.Metadata;
@using Microsoft.EntityFrameworkCore.ChangeTracking;
@using Task.ModelObjects;
@using Task.Components.Shared;
@using System.Linq.Expressions;
@using System.Reflection;

@inherits MainLayout

@inject IDbContextFactory<Context> ContextFactory;

@typeparam T where T : ModelObject;

<CascadingValue Value="this">
    <MainLayout>
        <style>
            .model-layout-input {
                padding: 6px;
                border-radius: 4px;
                border: 1px solid rgba(0, 0, 0, 0.4);
            }

            .input-holder {
                margin: 8px;
                display: inline-block;
            }
        </style>
        <h1>@GetTitle()</h1>
        <TaskSection Title="Properties">
            <div>
                @if(CurrentMode == Mode.Find)
                {
                    <TaskButton Type="TaskButton.ButtonType.Warning" Text="Find" OnClick="Find" />
                    <TaskButton Type="TaskButton.ButtonType.Positive" Text="Add" OnClick="SetAddMode"/>
                }
                else if(CurrentMode == Mode.Update)
                {
                    <TaskButton Type="TaskButton.ButtonType.Info" Text="Search" OnClick="Search"/>
                    <TaskButton Type="TaskButton.ButtonType.Positive" Text="Save" Disabled="!Changed"/>
                    <TaskButton Type="TaskButton.ButtonType.Warning" Text="Undo" OnClick="Undo" Disabled="!Changed" />
                    <TaskButton Type="TaskButton.ButtonType.Negative" Text="Delete" />
                }
                else if(CurrentMode == Mode.Insert)
                {
                    <TaskButton Type="TaskButton.ButtonType.Neutral" Text="Cancel" OnClick="Search"/>
                    <TaskButton Type="TaskButton.ButtonType.Positive" Text="Save" Disabled="!CanAdd" />
                }
            </div>
            <div>
                @try
                {
                    @foreach (PropertyInfo prop in Properties)
                    {
                        switch (prop.PropertyType)
                        {
                            default:
                                <div class="input-holder">
                                    <label for="@prop.Name">@prop.Name</label>
                                    <input id="@prop.Name" value="@PropertyValues[prop.Name]" class="model-layout-input" @onchange="((ChangeEventArgs e) => OnChange(e, prop.Name))" />
                                </div>
                                break;
                        }
                    }
                }
                catch (Exception e) { TaskError.HandleError(e); }
            </div>
        </TaskSection>
        @if (CurrentMode == Mode.Find && searchObjects != null)
        {
            <TaskSection Title="Results" NoPadding="true">
                <TaskGrid PrimaryObject="searchObjects" NoMargin="true" IsSelect="true" OnSelect="OnSelect"/>
            </TaskSection>
        }
        @Body
    </MainLayout>
</CascadingValue>

@code {
    public Guid? Identity { get; set; } = null;

    protected Type Type { get; set; } = typeof(T);

    protected List<PropertyInfo> Properties { get; set; } = ModelObject.GetProperties<T>()
        .Where(p => typeof(ModelObject)
            .GetProperties()
            .Select(pr => pr.Name)
            .Contains(p.Name) == false)
        .Where(p => p.PropertyType != typeof(Guid))
        .ToList();

    public bool Changed
    {
        get
        {
            bool res = false;
            try
            {
                if(CurrentMode == Mode.Update)
                {
                    foreach(PropertyInfo prop in Properties)
                    {
                        if(prop.PropertyType == typeof(string) && (string)prop.GetValue(current)! != PropertyValues[prop.Name])
                        {
                            res = true;
                            break;
                        }
                    }
                }
            } catch(Exception ex) { TaskError.HandleError(ex); }
            return res;
        }
    }

    public bool CanAdd
    {
        get
        {
            bool res = true;
            try
            {
                if(CurrentMode == Mode.Insert)
                {
                    foreach(PropertyInfo prop in Properties)
                    {
                        if(Nullable.GetUnderlyingType(prop.PropertyType) == null && PropertyValues[prop.Name] == string.Empty)
                        {
                            res = false;
                            break;
                        }
                    }
                }
                else
                {
                    res = false;
                }
            } catch(Exception ex) { TaskError.HandleError(ex); }
            return res;
        }
    }

    private Dictionary<string, string> PropertyValues { get; } = new Dictionary<string, string>();
    private List<T>? searchObjects;
    private T? current = null;

    protected override void OnParametersSet()
    {
        if(PropertyValues.Count == 0)
        {
            foreach (PropertyInfo prop in Properties)
            {
                PropertyValues.Add(prop.Name, string.Empty);
            }
        }
    }

    private void Search()
    {
        current = null;
        CurrentMode = Mode.Find;
    }

    private void Undo()
    {
        List<PropertyInfo> props = current!.GetProperties();
        props.ForEach(p =>
        {
            if (PropertyValues.ContainsKey(p.Name) && p.PropertyType == typeof(string))
            {
                string? val = (string?)p.GetValue(current);
                if (TypeCheck.NotEmpty(val))
                {
                    PropertyValues[p.Name] = val;
                }
                else
                {
                    PropertyValues[p.Name] = string.Empty;
                }

            }
        });
    }

    private async Task Find()
    {
        using(Context context = ContextFactory.CreateDbContext())
        {
            IEnumerable<string> navigationProperties = context.Model.FindEntityType(typeof(T))!
                .GetNavigations()
                .Select(n => n.Name);

            IQueryable<T> query = context.Set<T>();

            foreach (string navigationProperty in navigationProperties)
            {
                query = query.Include(navigationProperty); 
            }

            foreach(KeyValuePair<string, string> filter in PropertyValues.Where(p => TypeCheck.NotEmpty(p.Value)))
            {
                ParameterExpression parameter = Expression.Parameter(typeof(T), "t");
                MemberExpression property = Expression.Property(parameter, filter.Key);
                ConstantExpression value = Expression.Constant($"%{filter.Value}%");

                MethodInfo? likeMethod = typeof(DbFunctionsExtensions)
                    .GetMethod(nameof(DbFunctionsExtensions.Like), new[] { typeof(DbFunctions), typeof(string), typeof(string) })!;

                MethodCallExpression likeCall = Expression.Call(null, likeMethod, Expression.Constant(EF.Functions), property, value);

                Expression<Func<T, bool>> lambda = Expression.Lambda<Func<T, bool>>(likeCall, parameter);

                query = query.Where(lambda);
            }

            searchObjects = await query.ToListAsync();
        }
    }

    private async Task Add()
    {
        
    }

    private void OnSelect(object? obj)
    {
        if(TypeCheck.NotEmpty(obj) && obj is T instance)
        {
            current = instance;
            List<PropertyInfo> props = instance.GetProperties();
            props.ForEach(p =>
            {
                if (PropertyValues.ContainsKey(p.Name) && p.PropertyType == typeof(string))
                {
                    string? val = (string?)p.GetValue(instance);
                    if (TypeCheck.NotEmpty(val))
                    {
                        PropertyValues[p.Name] = val;
                    }
                    else
                    {
                        PropertyValues[p.Name] = string.Empty;
                    }

                }
            });
            SetUpdateMode();
        }
    }

    private void OnChange(ChangeEventArgs e, string key)
    {
        if(e.Value is string value)
        {
            PropertyValues[key] = value;
        }
    }

    private void SetAddMode()
    {
        current = null;
        CurrentMode = Mode.Insert;
    }

    private void SetUpdateMode()
    {
        CurrentMode = Mode.Update;
        using(Context context = ContextFactory.CreateDbContext())
        {
            T? obj = Activator.CreateInstance(Type) as T;

            if(TypeCheck.NotEmpty(obj))
            {
                EntityEntry entry = context.Entry(obj);

                //MethodInfo method = context.GetType().GetMethod("Set").MakeGenericMethod(Type);
                //object? dbSet = method.Invoke(context, null);


            }
        }
    }
}